#!/usr/bin/env bash
activitycolor="\033[44;93m"
fragmentcolor="\033[95m"
objectcolor="\033[2m"
reset="\033[0m"
activitycount=0
linecount=0
withinActivityBlock=false
timestamp=$(date +%s)
dsFileName=".ds_temp_file_$timestamp"
keepFile=false
useSpecificFile=""
NL=$'\n'

while getopts khf: flag
do
    case "${flag}" in
        h) 
            echo "TODO: Print help"
            exit 0
        ;;
        k) 
            echo "Keeping the file: $dsFileName"
            keepFile=true
            #shift 1
        ;;
        f) 
            useSpecificFile="${OPTARG}"
            echo "Using a specific file instead: $useSpecificFile"
        ;;
    esac
done

package=$1
if [ $# -eq 0 ]; then
    fzf_installed=$(which fzf)
    if [[ -z ${fzf_installed} ]]; then
        echo "FZF is NOT installed so you can not use the interactive package picker"
        echo "Install FZF to enable this feature"
        exit 1
    else
        packToUse=$(adb shell pm list package -3 | fzf | cut -d':' -f2)
        echo "Using package: $packToUse"
        package="$packToUse"
        if [[ -z "$package" ]]; then
            echo "No package provided!"
            exit 1
        fi
    fi
fi

# [a-zA-Z0-9]*\{[a-z0-9]{1,10}\}\ \(
# above but not including the BOTTOM ADDED FRAGMENTS
# [[:space:]]{2,}[a-zA-Z0-9]*\{[a-z0-9]{1,10}\}\ \(
# count number of leading zeros
# | awk -F'[^ ]' '{print length($1),NR}' | awk '{print $1}'

# The all important adb dumpsys command
if [[ -z "$useSpecificFile" ]]; then
    adb shell dumpsys activity "$package" > "$dsFileName"
else
    cat "$useSpecificFile" > "$dsFileName"
fi

#hmmmmmm
#sed -i '' 's/Active Fragments://g' "$dsFileName"
lineOne="$(grep -A 2 "^\ \ ACTIVITY" "$dsFileName")"
lineTwo="$(grep -B 6 "^[[:space:]]*mFragmentManager=FragmentManager" "$dsFileName")"
#lineThree="$(grep -E "^[[:space:]]*\#[0-9]*\:\ [a-zA-Z0-9]*\{[a-z0-9]*\}\ " "$dsFileName")"
lineThree="$(sed -n '/^\ \ \ \ Added\ Fragments\:/,/^\ \ \ \ Back\ Stack\:/p' "$dsFileName")"
#^[[:space:]]*\#[0-9]*\:\ [a-zA-Z0-9]*\{[a-z0-9]{1,10}\}\
# REPLACE the above with this grep
newInput="${lineOne}${NL}${lineTwo}${NL}${lineThree}"
echo -e "$newInput" > "$dsFileName"

input="$dsFileName"

#RECURSIVE function TODO
function getChildren(){
    #$1 - fragmentname, $2 - fragtmentObjectNum, $3 - depth, $4 - parentColumns
    local parentCols="$4"
    local dep=$3
    #gets all lines and the 6 lines after it (aka the blocks) MULTIPLE BLOCKS aka how many kids it has
    #where the line is the fragement from $1{$2}
    local grepBlockTopLevelCF=$(grep -B 6 "^[[:space:]]*mFragmentManager=FragmentManager.*$1{$2}" "$input")
    #NOTE unnecesasy check
    if ! [[ -z "$grepBlockTopLevelCF" ]]; then
        maxlines=$(echo "$grepBlockTopLevelCF" | wc -l)
        numOfKids=$((maxlines / 7))
        if [[ $numOfKids -gt 1 ]]; then
            parentCols="$parentCols,$dep"
        fi
        #TODO another loop here
        for ((n=0;n<$numOfKids;n++))
        do
            i=$((n+1))
            m7=$((8 * n))
            lineToRead=$((m7 + 1))
            childFragLine=$(echo "$grepBlockTopLevelCF" | sed -n "${lineToRead}p")
            #Here is where the problem is...TODO
            #sed -i '' 's/Active Fragments://g' "$dsFileName"
            childFragLine=$(echo "$childFragLine" | sed 's/Active Fragments://g')
            a=$(echo "$childFragLine" | tr -s ' ' | cut -d' ' -f2)
            b=$(echo "$a" | cut -d'{' -f1)
            c=$(echo "$a" | cut -d'{' -f2 | cut -d'}' -f1)

            SAVEIFS=$IFS
            IFS=',' read -r -a splitPars <<< "$parentCols"
            IFS=$SAVEIFS

            spacer=" "
            for ((j=0;j<$dep;j++))
            do
                if [[ "${splitPars[@]}" =~ "${j}" ]]; then
                    spacer="${spacer}│  "
                else
                    spacer="$spacer   "
                fi
            done
            if [[ $((n+1)) == $numOfKids ]]; then
                echo -e "${spacer}└─ ${fragmentcolor}$b${reset} - ${objectcolor}$c${reset}"
            else
                echo -e "${spacer}├─ ${fragmentcolor}$b${reset} - ${objectcolor}$c${reset}"
            fi
            #( time getChildren "$b" "$c" $((dep+1)) "$parentCols" )
            getChildren "$b" "$c" $((dep+1)) "$parentCols"
        done
    fi
}


#--------------------------
# Program logic starts here
#--------------------------
while IFS= read -r line
do
    linecount=$((linecount + 1))
    activityLine=$(echo "$line" | grep "^\ \ ACTIVITY" | sed -e 's/^[[:space:]]*//')
    if ! [[ -z "$activityLine" ]]; then
        withinActivityBlock=true
        activitycount=$((activitycount+1))
        activityDisplayLine=$(echo "$activityLine" | cut -d' ' -f2 | cut -d'/' -f2)
        activityStateLine=$(sed -n "$((linecount + 2))p" "$input")
        SAVEIFS=$IFS
        IFS=' ' read -r -a array <<< "$activityStateLine"
        IFS=$SAVEIFS
        resumedPreManip=$(echo "${array[0]}" | cut -d'=' -f2)
        resumedDisplay=""
        if [[ "$resumedPreManip" == true ]]; then
            resumedDisplay=" - \033[93mActive\033[0m"
        fi
        echo ""
        echo -e "${activitycolor}$activityDisplayLine${reset}$resumedDisplay"
    fi

    if [[ "$withinActivityBlock" == true ]]; then
        fragmentLine=$(echo "$line" | grep "^\ \ \ \ Added Fragments\:") #The starting spaces is what makes this work
        if ! [[ -z "$fragmentLine" ]]; then
            withinActivityBlock=false
            #This sed Prints from the line "    Added Fragments:" until the line with "    Back Stack" and only
            #greps the line that start with # which would be the 
            fragments=$(sed -n "$((linecount + 1)),/^[[:space:]]*Back\ Stack/p" "$input" | grep -n "^\ \ \ \ \ \ #")
            SAVEIFS=$IFS
            IFS=$'\n'
            fragmentlist=($fragments)
            IFS=$SAVEIFS
            #TODO another loop here
            #Loop few fragments at bootm of page
            for ((elm=0;elm<${#fragmentlist[@]};elm++))
            do
                element="${fragmentlist[$elm]}"
                #e.g. FragFragment{xxxxx} 
                eachFragWithObj=$(echo "$element" | tr -s ' ' | cut -d' ' -f3)
                #e.g. FragFragment
                eachFragment=$(echo "$eachFragWithObj" | cut -d'{' -f1)
                #e.g. xxxxx 
                eachObject=$(echo "$eachFragWithObj" | cut -d'{' -f2 | cut -d'}' -f1)
                #IF the index (elm) (+1) is same as the amount of fragments in list
                if [[ $((elm+1)) == ${#fragmentlist[@]} ]]; then
                    #If its the last in the list it curves off
                    echo -e "└─ ${fragmentcolor}$eachFragment${reset} - ${objectcolor}$eachObject${reset}"
                else
                    echo -e "├─ ${fragmentcolor}$eachFragment${reset} - ${objectcolor}$eachObject${reset}"
                fi
                #IMPORTANT Here only the top level fragments are
                # ... printed to the screen
                # ... children are now recursively found
                #TODO getChildren contains more loops complexity and time goes up
                getChildren "$eachFragment" "$eachObject" 1
            done
        fi
    fi
done < "$input"
echo "" 
if [[ "$keepFile" = false ]]; then
    rm "$dsFileName"
fi
